;; Compilation de fonctions.

(defun compilation-defun (exp env fenv nomf)
  (let ((nivem (assoc nomf fenv)))
    (append
    (list (append '(.class public) (list (car exp))))
    (list (append '(.super java/lang/Object) () ))
    (list (append '(.method public static) () (list (car exp)) '((I)I)))
    '((.limit local 1))
    '((.limit stack 3))
    '(iload 0)
    (compilation-progn (cddr exp)
		       (param-env (cadr exp) env 1 (if nivem (+ 1 (cadr nivem)) 0))
		       (fun-env (list exp) fenv (if nivem (+ 1 (cadr nivem)) 0))
		       (car exp))
    '((ireturn))
    '((.end method))
    '((method public static print(I)V))
    '((.limit local 1))
    '((.limit stack 2)=
    '((getstatic java/lang/System.out Ljava/io/PrintStream";"))
    '(iload 0)
    '(invokevirtual java/io/PrintStream/println(I)V)
    '(return)
    '(.end method)
    '(.method public static main("["Ljava/lang/String";")V)
    '(.limit locals 1)
    '(.limit stack 1)
    '(ldc 10)
    '(invokestatic)
    (list (car exp))
    '(/)
    (list (car exp))
    '((I)I)
    '(invokestatic)
    (list (car exp))
    '(/)
    '(print(I)V)
    '(return)
    '(.end method))
    )
  )
)

(defun concatString (list)
  "A non-recursive function that concatenates a list of strings."
  (if (listp list)
      (with-output-to-string (s)
         (dolist (item list)
           (if (stringp item)
             (format s "~a" item))))))

(defun compilation-print ()
    (append '(method public static print(I)V)
            '(.limit local 1)
            '(.limit stack 2)
            '(getstatic java/lang/System.out Ljava/io/PrintStream ";")
            '(iload 0)
            '(invokevirtual java/io/PrintStream/println(I)V)
            '(return)
            '(.end method)
          )
        )

(defun compilation-main (exp)
  (if (atom exp)
    (append '(.method public static main("["Ljava/lang/String";")V)
            '(.limit locals 1)
            '(.limit stack 1)
            '(ldc 10)
            '(invokestatic)
            (list exp)
            '(/)
            (list exp)
            '((I)I)
            '(invokestatic)
            (list exp)
            '(/)
            '(print(I)V)
            '(return)
            '(.end method)
          )
        )
      )

(defun param-env (exp env dep nivem)
  (if (atom exp)
      env
    (param-env (cdr exp) (cons (cons (car exp) `(LOC ,(- 0 dep) ,nivem)) env) (+ 1 dep) nivem)
    )
  )

(defun fun-env (exp fenv nivem)
  (if (atom exp)
      fenv
    (fun-env (cdr exp) (cons `(,(caar exp) ,nivem) fenv) nivem)
    )
  )

(defun compilation-appel (exp env fenv nomf)
  (let ((n (length (cdr exp)))
	(nivem (assoc (car exp) fenv)))
    (append (compilation-param (cdr exp) env fenv nomf)
      (list 'recursivecall)
      '(:iload 0)
      '(dup)
      '(ldc )
      '(isub)
      '(invokestatic)
      (list (car exp))
      '(imul)
      '(ireturn)
      '(end method))
    )
  )

(defun compilation-param (exp env fenv nomf)
  (if (atom exp)
      ()
    (append (compilation (car exp) env fenv nomf)
	    `((PUSH :R0))
	    (compilation-param (cdr exp) env fenv nomf))
    )
  )

(defun compilation-lambda (exp env fenv nomf)
  (let ((lambdaexpr (gensym "lambdaexpr"))
	(n (length (cdr exp)))
	(nivem (assoc nomf fenv)))
    (append (compilation-param (cdr exp) env fenv nomf)
	    `((PUSH (:DIESE ,n)))
	    `((MOVE :FP :R1))
	    `((MOVE :SP :FP))
	    `((MOVE :SP :R2))
	    `((SUB  (:DIESE ,n) :R2))
	    `((SUB  (:DIESE 1) :R2))
	    `((PUSH :R2))
	    `((PUSH :R1))
	    (if nivem  `((PUSH (:DIESE ,(+ 1 (cadr nivem)))))  `((PUSH (:DIESE ,0))))
	    `((PUSH (:DIESE 0)))
	    (compilation (caddar exp)
			 (param-env (cadar exp) env 1 (if nivem   (+ 1 (cadr nivem)) 0))
			 (fun-env  (list (cons lambdaexpr (cdar exp))) fenv (if nivem (+ 1 (cadr nivem)) 0))
			 lambdaexpr)
	    `((MOVE ( 1 :FP) :SP))
	    `((MOVE ( 2 :FP) :FP)))
    )
  )
