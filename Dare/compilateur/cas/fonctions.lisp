(defun list-to-string (lst)
  (format nil "~{~A~}" lst))

(defun concatString (list)
  (if (listp list)
    (with-output-to-string (s)
      (dolist (item list)
        (if (stringp item)
          (format s "~a" item))))))
;; Compilation de fonctions.

(defun compilation-defun (exp env fenv nomf)
  (let ((nivem (assoc nomf fenv)))
    (append
    (list (concatenate 'string ".class public " (string-capitalize (list-to-string (list (car exp))))))
    (list ".super java/lang/Object" )
    (list (concatenate 'string ".method public static " (string-downcase (list-to-string (list (car exp)))) "(I)I"))
    (list "limit local 1")
    (list "limit stack 3")
    (compilation-progn (cddr exp)
		       (param-env (cadr exp) env 1 (if nivem (+ 1 (cadr nivem)) 0))
		       (fun-env (list exp) fenv (if nivem (+ 1 (cadr nivem)) 0))
		       (car exp))
    (list "ireturn")
    (list ".end method")
    (list "method public static print(I)V")
    (list ".limit local 1")
    (list ".limit stack 2")
    (list "getstatic java/lang/System.out Ljava/io/PrintStream;")
    (list "iload 0")
    (list "invokevirtual java/io/PrintStream/println(I)V")
    (list "return")
    (list ".end method")
    (list ".method public static  main([Ljava/lang/String;)V")
    (list ".limit locals 1")
    (list ".limit stack 1")
    (list "ldc 10")
    (list "invokestatic Fact/fact(I)I")
    (list (concatenate 'string "invokestatic "
      (string-capitalize (list-to-string (list (car exp)))) "/"
        (string-downcase (list-to-string (list (car exp)))) "(I)I"))
    (list (concatenate 'string "invokestatic "
      (string-capitalize (list-to-string (list (car exp)))) "/print(I)V"))
    (list "return")
    (list ".end method")
    )
  ))

(defun compilation-print ()
    (append '(method public static print(I)V)
            '(.limit local 1)
            '(.limit stack 2)
            '(getstatic java/lang/System.out Ljava/io/PrintStream ";")
            '(iload 0)
            '(invokevirtual java/io/PrintStream/println(I)V)
            '(return)
            '(.end method)
          )
        )

(defun compilation-main (exp)
  (if (atom exp)
    (append '(.method public static main("["Ljava/lang/String";")V)
            '(.limit locals 1)
            '(.limit stack 1)
            '(ldc 10)
            '(invokestatic)
            (list exp)
            '(/)
            (list exp)
            '((I)I)
            '(invokestatic)
            (list exp)
            '(/)
            '(print(I)V)
            '(return)
            '(.end method)
          )
        )
      )

(defun param-env (exp env dep nivem)
  (if (atom exp)
      env
    (param-env (cdr exp) (cons (cons (car exp) `(LOC ,(- 0 dep) ,nivem)) env) (+ 1 dep) nivem)
    )
  )

(defun fun-env (exp fenv nivem)
  (if (atom exp)
      fenv
    (fun-env (cdr exp) (cons `(,(caar exp) ,nivem) fenv) nivem)
    )
  )

(defun compilation-appel (exp env fenv nomf)
  (let ((n (length (cdr exp)))
	(nivem (assoc (car exp) fenv)))
    (append (compilation-param (cdr exp) env fenv nomf)
      (list 'recursivecall)
      '(:iload 0)
      '(dup)
      '(ldc )
      '(isub)
      '(invokestatic)
      (list (car exp))
      '(imul)
      '(ireturn)
      '(end method))
    )
  )

(defun compilation-param (exp env fenv nomf)
  (if (atom exp)
      ()
    (append (compilation (car exp) env fenv nomf)
	    `((PUSH :R0))
	    (compilation-param (cdr exp) env fenv nomf))
    )
  )

(defun compilation-lambda (exp env fenv nomf)
  (let ((lambdaexpr (gensym "lambdaexpr"))
	(n (length (cdr exp)))
	(nivem (assoc nomf fenv)))
    (append (compilation-param (cdr exp) env fenv nomf)
	    `((PUSH (:DIESE ,n)))
	    `((MOVE :FP :R1))
	    `((MOVE :SP :FP))
	    `((MOVE :SP :R2))
	    `((SUB  (:DIESE ,n) :R2))
	    `((SUB  (:DIESE 1) :R2))
	    `((PUSH :R2))
	    `((PUSH :R1))
	    (if nivem  `((PUSH (:DIESE ,(+ 1 (cadr nivem)))))  `((PUSH (:DIESE ,0))))
	    `((PUSH (:DIESE 0)))
	    (compilation (caddar exp)
			 (param-env (cadar exp) env 1 (if nivem   (+ 1 (cadr nivem)) 0))
			 (fun-env  (list (cons lambdaexpr (cdar exp))) fenv (if nivem (+ 1 (cadr nivem)) 0))
			 lambdaexpr)
	    `((MOVE ( 1 :FP) :SP))
	    `((MOVE ( 2 :FP) :FP)))
    )
  )
